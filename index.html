<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sopa de Letras 14√ó14</title>
<style>
  :root{
    --accent:#2563eb;
    --found:#a7f3d0;
    --select:#bfdbfe;
    --grid-gap: clamp(2px,0.6vw,6px);
    --cell-size: clamp(34px, 7.2vw, 52px);
    --radius: 12px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    background:#f8fafc; color:#0f172a; line-height:1.35;
    display:flex; min-height:100dvh; flex-direction:column;
  }
  header{
    padding:14px 16px; background:white; box-shadow:0 2px 10px rgba(15,23,42,.05);
    position:sticky; top:0; z-index:5;
  }
  h1{margin:0; font-size:clamp(18px,5.2vw,24px)}
  main{padding:14px; display:grid; gap:16px; max-width:900px; width:100%; margin:0 auto}
  .card{
    background:white; border-radius:16px; box-shadow:0 8px 30px rgba(15,23,42,.06); padding:12px;
  }
  .grid{
    display:grid;
    grid-template-columns: repeat(14, var(--cell-size));
    justify-content:center;
    gap: var(--grid-gap);
    touch-action: none; /* mejora el drag en m√≥vil */
    user-select:none;
  }
  .cell{
    width:var(--cell-size);
    aspect-ratio:1;
    display:grid; place-items:center;
    font-weight:700; font-size:clamp(16px,4.8vw,22px);
    border:2px solid #cbd5e1; border-radius:10px; background:#fff;
    transition:transform .05s ease, background .15s ease, border-color .15s ease;
  }
  .cell:active{ transform:scale(.98) }
  .cell.selecting{ background: var(--select); border-color:#93c5fd }
  .cell.found{ background: var(--found); border-color:#34d399 }
  .legend h2{font-size:18px; margin:0 0 8px}
  .words{display:grid; grid-template-columns:1fr 1fr; gap:6px 16px; font-size:16px}
  .word{display:flex; align-items:center; gap:8px}
  .word.done{ color:#065f46; text-decoration: line-through; }
  .badge{display:inline-grid; place-items:center; width:22px; height:22px; border-radius:999px; background:#e2e8f0; font-size:12px; font-weight:700;}
  .word.done .badge{ background:#34d399; color:white }
  .hint{font-size:13px; color:#475569; margin-top:8px}
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; margin:6px 0 10px}
  button{
    padding:10px 14px; border-radius:12px; border:1px solid #cbd5e1;
    background:#f1f5f9; font-weight:700; cursor:pointer;
  }
  button.primary{ background:var(--accent); color:white; border-color:var(--accent) }
  .footer{font-size:12px; color:#64748b; text-align:center; padding:16px}
  /* Modal final */
  .modal{
    position:fixed; inset:0; background:rgba(2,6,23,.56);
    display:none; align-items:center; justify-content:center; z-index:10;
  }
  .modal.show{ display:flex }
  .modal .box{
    background:white; padding:20px; border-radius:18px; max-width:520px; width:92%;
    text-align:center; box-shadow:0 20px 60px rgba(2,6,23,.33);
  }
</style>
</head>
<body>
<header><h1>üß© Sopa de Letras 14√ó14</h1></header>
<main>
  <section class="card">
    <div class="toolbar">
      <button class="primary" id="btnNueva">üîÅ Nueva sopa</button>
      <button id="btnRevelar">üëÄ Mostrar/Ocultar soluci√≥n</button>
    </div>
    <div id="grid" class="grid" aria-label="Sopa de letras"></div>
    <p class="hint">Toc√° y arrastr√° para seleccionar. Orientaciones incluidas: izquierda‚Üíderecha, arriba‚Üíabajo y diagonal ‚Üò.</p>
  </section>

  <section class="card legend">
    <h2>Palabras a buscar</h2>
    <div id="lista" class="words"></div>
  </section>
</main>

<div class="footer">Hecho con ‚ù§Ô∏è </div>

<!-- Modal final -->
<div class="modal" id="modalFin" role="dialog" aria-modal="true">
  <div class="box">
    <h2>¬°Completado! üéâ</h2>
    <p>¬°Gracias por participar! Encontraste todas las palabras.</p>
    <button id="btnCerrarModal" class="primary">Aceptar</button>
  </div>
</div>

<script>
/* ===== Config ===== */
const N = 14;
const palabrasOriginales = [
  "Hermen√©utica", "Comprensi√≥n", "Subjetividad",
  "Ciencia", "Esp√≠ritu", "Experiencia", "Vivida"
];
// Permitimos estas direcciones (no hay palabras al rev√©s en la grilla)
const DIRECCIONES = {
  H: {dx:1, dy:0},   // izquierda -> derecha
  V: {dx:0, dy:1},   // arriba -> abajo
  D: {dx:1, dy:1}    // diagonal ‚Üò
};
// Queremos mezclar: m√≠nimo 3 horizontales, 2 verticales, 1 diagonal
const MIN_REQ = {H:3, V:2, D:1};

/* ===== Utiles ===== */
const sinTildes = s => s.normalize('NFD').replace(/\p{Diacritic}/gu,'');
const toGridWord = s => sinTildes(s).replace(/\s+/g,'').toUpperCase();
const palabras = palabrasOriginales.map(toGridWord);

function rngChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function dentro(x,y){ return x>=0 && y>=0 && x<N && y<N; }

/* ===== Generaci√≥n de sopa ===== */
function generarSopa() {
  // Direcciones objetivo para cada palabra (misma longitud del array palabras)
  let dTags = [];
  dTags.push(...Array(MIN_REQ.H).fill('H'));
  dTags.push(...Array(MIN_REQ.V).fill('V'));
  dTags.push(...Array(MIN_REQ.D).fill('D'));
  while (dTags.length < palabras.length) dTags.push(rngChoice(['H','V']));
  // Ordenar por longitud desc. y barajar ligeramente
  const orden = palabras
    .map((w,i)=>({w,i,len:w.length}))
    .sort((a,b)=> b.len - a.len);

  for (let intento=0; intento<200; intento++){
    const grid = Array.from({length:N}, ()=> Array(N).fill(''));
    const placements = []; // {word, x,y, dx,dy, idx}
    const asignadas = [...dTags].sort(()=>Math.random()-0.5);

    let ok = true;
    for (let k=0; k<orden.length; k++){
      const {w, i:idx} = orden[k];
      const tag = asignadas[k];
      const {dx,dy} = DIRECCIONES[tag];

      // probar muchas posiciones aleatorias para esa palabra
      const coords = [];
      for (let y=0;y<N;y++) for (let x=0;x<N;x++) coords.push([x,y]);
      coords.sort(()=>Math.random()-0.5);

      let puesta = false;
      for (const [x0,y0] of coords){
        const x1 = x0 + dx*(w.length-1), y1 = y0 + dy*(w.length-1);
        if (!dentro(x1,y1)) continue;
        // chequear colisiones (permitimos cruzar con misma letra)
        let okWord = true;
        for (let i=0;i<w.length;i++){
          const x=x0+dx*i, y=y0+dy*i;
          const c = grid[y][x];
          if (c && c!==w[i]) { okWord=false; break; }
        }
        if (!okWord) continue;
        // colocar
        for (let i=0;i<w.length;i++){
          const x=x0+dx*i, y=y0+dy*i;
          grid[y][x] = w[i];
        }
        placements.push({word:w, x:x0, y:y0, dx, dy, idx});
        puesta = true; break;
      }
      if (!puesta){ ok=false; break; }
    }
    if (!ok) continue;

    // rellenar vac√≠os
    const ABC = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (let y=0;y<N;y++) for (let x=0;x<N;x++)
      if (!grid[y][x]) grid[y][x] = ABC[Math.floor(Math.random()*ABC.length)];

    return {grid, placements};
  }
  throw new Error("No se pudo generar la sopa con las restricciones.");
}

/* ===== Render ===== */
const $grid = document.getElementById('grid');
const $lista = document.getElementById('lista');
const $btnNueva = document.getElementById('btnNueva');
const $btnRevelar = document.getElementById('btnRevelar');
const $modalFin = document.getElementById('modalFin');
const $btnCerrarModal = document.getElementById('btnCerrarModal');

let state = {
  grid: null,
  placements: null,
  found: new Set(),          // √≠ndices de palabra encontrada
  reveal: false,
  selecting: false,
  path: [],                  // celdas [x,y]
  startCell: null,
};

function dibujarLista(){
  $lista.innerHTML='';
  palabrasOriginales.forEach((p, i)=>{
    const div=document.createElement('div'); div.className='word'+(state.found.has(i)?' done':'');
    const b=document.createElement('span'); b.className='badge'; b.textContent=state.found.has(i)?'‚úì':(i+1);
    const t=document.createElement('span'); t.textContent=p;
    div.append(b,t); $lista.append(div);
  });
}

function key(x,y){return `${x},${y}`}

function renderGrid(){
  $grid.innerHTML='';
  for (let y=0;y<N;y++){
    for (let x=0;x<N;x++){
      const btn = document.createElement('div');
      btn.className = 'cell';
      btn.textContent = state.grid[y][x];
      btn.setAttribute('role','button');
      btn.setAttribute('aria-label', `Fila ${y+1}, Columna ${x+1}, letra ${state.grid[y][x]}`);
      btn.dataset.x = x; btn.dataset.y = y;
      $grid.append(btn);
    }
  }
  pintarSolucion(state.reveal);
}

function pintarSolucion(show){
  // reset
  $grid.querySelectorAll('.cell').forEach(c=>{
    c.classList.remove('found');
  });
  // pintar encontradas o soluci√≥n si reveal
  state.placements.forEach(p=>{
    const idx = p.idx;
    if (state.found.has(idx) || show){
      for (let i=0;i<p.word.length;i++){
        const x=p.x+p.dx*i, y=p.y+p.dy*i;
        const cell = $grid.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
        if (cell) cell.classList.add('found');
      }
    }
  });
}

/* ===== Selecci√≥n t√°ctil/rat√≥n ===== */
function cellFromEvent(e){
  const touch = e.touches?.[0] ?? e.changedTouches?.[0];
  const target = (touch ? document.elementFromPoint(touch.clientX, touch.clientY) : e.target);
  if (!target || !target.classList.contains('cell')) return null;
  return target;
}
function startSelect(e){
  const el = cellFromEvent(e);
  if (!el) return;
  state.selecting = true;
  state.path = [];
  state.startCell = el;
  pushCell(el);
  e.preventDefault();
}
function moveSelect(e){
  if (!state.selecting) return;
  const el = cellFromEvent(e);
  if (!el) return;
  pushCell(el);
}
function endSelect(e){
  if (!state.selecting) return;
  state.selecting = false;
  checkSelection();
  clearSelecting();
}

function pushCell(el){
  const x = +el.dataset.x, y = +el.dataset.y;
  const last = state.path[state.path.length-1];
  // evitar duplicados consecutivos
  if (last && last.x===x && last.y===y) return;

  // si ya hay 2 puntos, obligar a l√≠nea recta en H, V o D
  if (state.path.length>=1){
    const x0 = state.path[0].x, y0 = state.path[0].y;
    const dx = Math.sign(x - x0), dy = Math.sign(y - y0);
    // s√≥lo permitir (1,0), (0,1), (1,1) o sus opuestos durante la selecci√≥n
    const valid = (dx===1&&dy===0)||(dx===0&&dy===1)||(dx===1&&dy===1)||(dx===-1&&dy===0)||(dx===0&&dy===-1)||(dx===-1&&dy===-1);
    if (!valid) return;
    // forzar a la l√≠nea: si no est√° en la l√≠nea recta, ignorar
    const onLine = (x-x0===y-y0) || (x===x0) || (y===y0);
    if (!onLine) return;
  }
  state.path.push({x,y});
  el.classList.add('selecting');
}

function clearSelecting(){
  $grid.querySelectorAll('.cell.selecting').forEach(c=>c.classList.remove('selecting'));
  state.path=[];
}

function checkSelection(){
  if (state.path.length<2) return;
  // construir palabra seleccionada (permitimos arrastrar en ambos sentidos por UX)
  const letters = state.path.map(p=> state.grid[p.y][p.x]).join('');
  const rev = letters.split('').reverse().join('');
  const pick = toGridWord(letters);
  const pickRev = toGridWord(rev);

  // ¬øcoincide con alguna palabra a√∫n no encontrada?
  let hitIdx = -1, placement=null;
  for (const p of state.placements){
    if (state.found.has(p.idx)) continue;
    const target = p.word;
    if (pick===target || pickRev===target){
      hitIdx = p.idx; placement = p; break;
    }
  }
  if (hitIdx>=0){
    // marcar celdas definitivas
    if (placement){
      for (let i=0;i<placement.word.length;i++){
        const x=placement.x+placement.dx*i, y=placement.y+placement.dy*i;
        const cell=$grid.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
        if (cell) cell.classList.add('found');
      }
    } else {
      // fallback: pintar las seleccionadas
      state.path.forEach(p=>{
        const cell=$grid.querySelector(`.cell[data-x="${p.x}"][data-y="${p.y}"]`);
        if (cell) cell.classList.add('found');
      });
    }
    state.found.add(hitIdx);
    dibujarLista();
    if (state.found.size===palabras.length){
      document.getElementById('modalFin').classList.add('show');
    }
  }
}

/* ===== Eventos globales ===== */
$grid.addEventListener('pointerdown', startSelect);
$grid.addEventListener('pointermove', moveSelect);
window.addEventListener('pointerup', endSelect);
// soporte t√°ctil pasivo
$grid.addEventListener('touchstart', startSelect, {passive:false});
$grid.addEventListener('touchmove', moveSelect, {passive:false});
window.addEventListener('touchend', endSelect);

$btnNueva.addEventListener('click', init);
$btnRevelar.addEventListener('click', ()=>{
  state.reveal = !state.reveal;
  pintarSolucion(state.reveal);
});
$btnCerrarModal.addEventListener('click', ()=> $modalFin.classList.remove('show'));

/* ===== Init ===== */
function init(){
  const {grid, placements} = generarSopa();
  state.grid = grid;
  state.placements = placements;
  state.found = new Set();
  state.reveal = false;
  renderGrid();
  dibujarLista();
  $modalFin.classList.remove('show');
}
init();
</script>
</body>
</html>
